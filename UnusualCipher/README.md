# Нестандартная криптография

Ссылка на видео https://www.youtube.com/watch?v=SJD_T8O_s_4

Доклад посвящён нетривиальным криптографическим схемам, которые применяются в реальных системах. Я постараюсь изложить материал доступно и понятно, добавив свои размышления и примеры (в один момент сам переставал понимать, так так начаниался тема про блокчейн).

## Ключевые идеи доклада

1. **Схема разделения секрета (Шамира)**. Секрет (например, приватный ключ или пароль) кодируется коэффициентом случайного полинома, а участникам раздаются его значения в разных точках. Требуется собрать некоторое минимальное количество точек, чтобы восстановить секрет. Это надёжный, чисто алгебраический метод, устойчивый даже к квантовым компьютерам. Пример практического применения – HashiCorp Vault: при «разблокировке» хранилища необходимо получить подписи нескольких доверенных узлов, чтобы восстановить мастер-ключ.
2. **Пороговые и агрегированные подписи**. Пороговые подписи позволяют нескольким участникам (M из N) совместно подписать одно сообщение так, чтобы получилась одна электронная подпись. При этом существуют разные варианты: отвечающие (accountable), когда известен конкретный набор подписантов, и анонимные (non-accountable), когда известно только то, что нужное число участников подписало, но их личности скрыты. Агрегируемые подписи позволяют сжать N обычных подписей в одну короткую – это важно для экономии места и ускорения проверки. Особенно наглядно это демонстрируют подписи BLS (на кривой BLS12-381), которые короткие (256 бит), детерминированные и по своей природе легко агрегируются.
3. **Детерминированные подписи**. В традиционных схемах электронная подпись может включать случайный фактор, из-за чего одна и та же пара сообщение–ключ может дать разный результат. Детерминированная подпись генерируется всегда одинаково (без рандома), что удобно для масштабирования: одна и та же совокупность участников всегда даст одну и ту же итоговую подпись. Это важно для консенсусных сетей, где порядок и повторение подписей не должны влиять на результат.
4. **Пороговая BLS-подпись**. Комбинируя идеи пороговых и BLS-подписей, получают протокол, где в ходе распределённого генератора ключей (DKG) все участники получают свои «доли» секрета, а при подписании собираются M частичных подписей. Проверка производится одним общим публичным ключом, а итоговая подпись коротка и детерминирована. Такой подход позволяет, например, валидировать блок, подписанный несколькими нодами, одной быстрой операцией проверки.
5. **Кольцевые подписи**. Это особый вид подписей, дающий анонимность: сообщение подписывает кто-то из группы N участников, но проверить, кто именно – невозможно . При этом видно, что подпись достоверна и принадлежит именно группе. В докладе приводился классический пример: самураи переписывали письмо и ставили подписи в круг, чтобы не выдать первого, кто подписал письмо . На современном языке – знаменитая статья «To Secret» про сотрудников, которые хотят анонимно «слить» информацию, сохраняя авторитетность подписи . Кольцевые подписи лежат в основе анонимных криптовалют типа Monero: транзакции подписаны одним из участников кольца, но отправителя узнать нельзя.
6. **Proof of membership (Set Membership Proofs)**. Специальный класс доказательств с нулевым разглашением, позволяющих показать, что некоторое значение принадлежит определённому множеству или корректно преобразовано функцией, не раскрывая его самого . Например, вы можете доказать, что знаете числовой баланс в этом списке, или что ваша учётная запись включена в реестр, не раскрывая причину. Примеры применения: анонимное голосование (например, протокол Semaphore или миксер Tornado Cash) и приватные креденшн-решения (подробнее ниже).
7. **ZK-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)**. Набор свойств современных доказательств: *Zero-Knowledge* означает, что проверяющий ничего не узнаёт про скрытые данные, кроме того факта, что «такое решение существует» . *Succinct* (компактность) – проверка доказательства заметно проще и быстрее самой вычислительной задачи. *Non-interactive* – всё делается одним пакетом доказательства без обмена сообщениями, что важно в блокчейне. *Argument of Knowledge* подчёркивает, что доказывающий действительно знает некоторую информацию (например, входное значение), давшую результат. Такие доказательства особенно полезны для «доверенного заверения» сложных вычислений или членства в множестве без раскрытия самих данных.
8. **Деревья Меркла**. Это древовидная структура, где каждый узел хранит хеш своих «детей». Корень дерева (Merkle root) надёжно «коммитит» весь набор данных. Чтобы доказать, что конкретный элемент (лист) A входит в дерево, достаточно предъявить последовательность хешей соседних узлов вдоль пути от листа к корню  . Проверяющий последовательно комбинирует их и убеждается, что итоговый хеш совпадает с корнем. Такая схема позволяет быстро доказывать целостность данных (например, кусочки файлов в торрентах) и проверять членство элементов без раскрытия всей базы  . Это очень распространённый инструмент в блокчейне и других распределённых системах.
9. **Verifiable Credentials (проверяемые учётные данные)**. Идея из области децентрализованной идентификации: эмитент (например, банк или правительство) выдаёт субъекту некие «удостоверения» (например, справки о доходе), подкреплённые криптографией. В докладе приводился пример: банк формирует Меркл-дерево всех балансов клиентов, подписывает корень, а пользователь доказывает в сети, что его баланс (лист дерева) принадлежит этому дереву, не раскрывая сам баланс полностью . При этом публичная сеть видит только корень дерева и короткое ZKP-доказательство. Таким образом проверяющий убеждается, что «пользователь действительно имеет на балансе X рублей», не получая дополнительных данных. Этот подход позволяет строить приватные и верифицируемые аттестации на блокчейне без публикации всех данных.
10. **Verkle-деревья и векторные коммитменты**. Это более современные структуры, которые развивают идею Меркла. В Verkle-дереве каждый узел – это не просто хеш, а криптографический коммитмент к вектору значений. Ключевая особенность – доказательство принадлежности одного элемента к мега-вектору может иметь *постоянный* размер, а не расти с высотой дерева . Проще говоря: если Меркл-дерево требует O(log N) хешей в доказательстве, то Verkle (в связке с ZK-коммитментами) сжимает всё в константный размер благодаря SNARK. В Ethereum и других проектах сейчас переезжают на такие Verkle-структуры, чтобы хранить состояние сети: это позволяет экономить место и ускорить работу при доказательствах наличия данных.

## Разделение секрета

Схема Шамира (часто называют «Шеринг Шамира») предназначена для надёжного хранения и восстановления секретов. Идея проста: представим, что секрет – число *S* (например, приватный ключ). Генерируется случайный полином степени *d*, у которого свободный коэффициент равен *S*. Далее любые *d+1* значений этого полинома по разным точкам (обычно узлам) выдаются участникам. Поскольку полином  степени *d* точно восстанавливается по *d+1* точкам, любая группа из *d+1* долей может вычислить все коэффициенты полинома и вернуть *S* (свободный член). **Важно**, что если собрать меньше точек (≤ d), секрет остаётся неузнаваем – дроби полинома слишком малы для восстановления.

Такая схема позволяет хранить ценные данные (пароли, ключи, документы) распределённо: если какой-то сервер упадёт или его взломают, секрет останется в безопасности, пока не собрана нужная пороговая группа. Примеры применения: хранение персональных паролей, секретных ключей шифрования и приватных ключей для ЭЦП. Например, HashiCorp Vault при «разблокировке» требует подписи минимум трёх доверенных узлов; сама же мастер-доля ключа хранится через схему Шамира, чтобы один взломанный сервер не раскрыл главный ключ.

**Преимущества схемы Шамира**: она чисто алгебраическая, не опирается на труднореализуемые задачи (типа логарифмов), поэтому надёжно защищена и от квантовых компьютеров. Иными словами, даже продвинутый квантовый компьютер не поможет собрать «швепс-раскладки» вместо полинома. 

**Недостаток** – требуется безопасно генерировать полином и защищать сами доли от перехвата, но при правильной организации эти риски минимальны.  В целом, схемы разделения секрета – зрелая и проверенная технология, и Сергей подчеркнул, что они уже давно используются в критичных системах, а не только в академических примерах.

## Подписи

**Пороговые подписи** – это обобщение Шамира на случай электронной подписи. Когда несколько участников (серверов или людей) должны вместе подписать одно сообщение, им удобно получить единый цифровой отпечаток. Работает так: с помощью распределённой генерации ключей (DKG) устанавливается общий «секретный ключ» в виде долей у N участников. Затем любая подгруппа из M участников может сгенерировать свои частичные подписи и скомбинировать их в одну итоговую подпись. Проверка делается одним общим открытым ключом – так, как если бы подпись был сделан одним человеком .

**Агрегированные подписи** сводят сразу несколько подписей в одну. Это не пороговая схема – здесь все участники уже подписи поставили, и задача лишь «сжать» их. Традиционно проверка n разных подпись дорогая (нужно проверять каждую). В случае агрегированных BLS-подписей все отдельные подписи и все открытые ключи объёмно объединяются в единый компактный объект. Проверка агрегата выполняется одним действием, что значительно эффективнее . В итоге «N подписей» превращаются в подпись постоянного размера (256 бит) и лист публичных ключей; верификация остаётся О(1) по затратам . Это критично для масштабирования сетей, где за один блок собираются подписи сотен узлов.

**Детерминированные подписи** – вариант схемы подписи, где для данного сообщения и ключа всегда получается одна и та же подпись (отсутствует рандомизация в алгоритме). Большинство «классических» EC-подписей обладает маллеабилити: подпись может быть изменена при сохранении валидности. Детерминированность исключает это: «одно сообщение + ключ = единственная сигнатура». Это удобно для кэширования и детерминированного реплей-сопротивления. В докладе упоминалось, что стандартные подписи (например, в HTTPS) ненадёжны для таких задач, и детерминированность – важное свойство современных схем . Многие новые протоколы (особенно на основе BLS) подразумевают детерминированный выход как элемент безопасности и предсказуемости.

**Пороговая BLS-подпись.** Здесь сочетаются вышеописанные механики. Сначала участники выполняют T-out-of-N DKG для «общего» секрета (используя алгоритмы распределённого шифрования по кривой BLS12-381). В результате формируется общий публичный ключ, а каждый держит свою долю приватного. При подписании каждый из M участников подписывает сообщение своей долей (обычная BLS-подпись на базе SHA256). Далее частичные подписи собираются в единый массив и конструируется итоговый SIG. Проверка делается так же, как одиночная BLS-подпись по общему ключу. Отсюда выходит детерминированность итогового SIG  и свойство агрегируемости. То есть, подпись, верифицированная общим ключом, выглядит неотличимо от обычной, хотя её на самом деле поставила группа из M людей. Такая схема особенно перспективна там, где нужно подтверждение большого кворума одним хешом (например, в системах Proof-of-Stake или консенсус-протоколах).

**Кольцевые подписи.** В отличие от пороговых, здесь принцип другой: нет заранее определённого порога и нет координации между участниками. Есть группа людей (или ключей) – «кольцо», – и любой может анонимно подписать сообщение так, что подписант скроется среди членов группы. Концепция простая: подписывающий включает в подпись список из N публичных ключей, создаёт специальный хешовый «кольцевой» вариант сигнатуры, в котором свой реальный ключ маскируется рандомными комбинациями остальных. В итоге проверяющий видит, что подпись годна и принадлежит одному из участников списка, но не знает – кому именно .

В докладе приводился пример древней истории: само письмо самураев, где они хотели опубликовать коллективное послание властям, но скрыть, кто первым его подписал (чтобы не подвергнуться гонениям). Самураи по очереди ставили подпись и создавали «кольцевой» сертификат, так что сёгун узнал, что послание от их клана, но не смог повесить конкретного человека. В современном мире такой же механизм лежит в основе Monero: отправитель (участник кольца) подписывает транзакцию «от имени» группы, и никто не может точно указать, кто именно был автором.

## **How to leak a secret**

Также в докладе упомянута известная статья **“How to leak a secret”:**

Статья разбирает несколько техник «стеганографии» и «кооперативного» протоколирования, показывая, как два участника могут передавать секрет, маскируя его в видимых сообщениях.

Авторы рассматривают задачу: есть два агента, А и В, которые хотят обменяться секретным сообщением S, но весь их трафик просматривается надзором. Как передать S так, чтобы надзор ничего не заметил? Статья показывает, что это возможно, если агенты заранее договорились о стратегиях кодирования, и описывает несколько конкретных схем.

### 1. Основные понятия и постановка задачи

**Участники и канал**

- **Агент А** (отправитель) и **агент В** (получатель) обмениваются публичными сообщениями, каждое просматривают надзорные органы.
- **Секрет S** – битовая строка, которую нужно передать незаметно.
- **Надзор** – наблюдатель, видит все сообщения, но не знает заранее стратегию кодирования.

**Стеганографический подход**

- Стеганография прячет информацию в «чистой» передаче (тексте, изображении), не меняя объёма видимого трафика.
- Требует:
    1. **Общий ключ** или предварительная договорённость о методе кодирования.
    2. **Случайность** – чтобы распределение закодированных сообщений совпадало с обычным.

---

### 2. Схемы скрытой передачи

**Кодирование в порядках сообщений**

Агенты заранее договариваются чередовать определённые «обычные» фразы или заголовки.

- Например, если А хочет передать 1, он вставляет фразу «Как дела?» перед основным текстом; если 0 – «Привет!»; получатель В по наличию фразы восстанавливает биты.

**Использование задержек (timing channel)**

- Передача бита 1 = задержка ответа на t₁ секунд, бита 0 = задержка t₀.
- Надзор видит только что есть задержки, но не знает, какие интервалы соответствуют 0 и 1.

**Кооперативное кодирование в пакетных заголовках**

- В сетевых протоколах (TCP/IP) заголовки содержат поля, которые легко подменить в допустимых пределах (например, идентификатор пакета, флаги).
- А кодирует биты S в неиспользуемых или «резервных» полях; В считывает их из тех же полей.

---

### 3. Надёжность и скрытность

**Статистический анализ**

- Надзор может собирать статистику по «обычному» трафику и замечать аномалии.
- Задача схемы – сохранить распределения полей и задержек такими же, как в обычном трафике.

**Шумовой канал и исправление ошибок**

- В канале возможны потери/изменения сообщений.
- Авторы предлагают добавить избыточность (коды исправления ошибок), чтобы В мог восстановить S даже при искажениях.

---

### 4. Практические примеры

| Метод | Преимущество | Недостаток |
| --- | --- | --- |
| Фразы-маркеры | Просто реализуется | Легко заметить при частом использовании |
| Временные интервалы | Незаметно для контента | Чувствительно к сетевым задержкам |
| Заголовки пакетов | Высокая скорость передачи | Требует доступа к низкоуровневым данным |

---

### 5. Выводы и рекомендации

1. **Предварительная договорённость** обязательна: без общего ключа или протокола скрыть информацию невозможно.
2. **Имитация нормального трафика**: нужно изучить профиль обычного обмена и точно ему соответствовать.
3. **Исправление ошибок** повышает надёжность, но увеличивает избыточность.
4. **Гибридные схемы** (комбинировать несколько методов) делают утечку ещё менее заметной.


## Сложные темы (я сам не справился, пришлось читерить)

**Доказательства принадлежности к множеству (Set Membership Proofs).** Эти протоколы построены на совмещении Меркл-деревьев и ZK-доказательств. Общая задача: есть большое множество (или зафиксированная функция), и доказывающий хочет показать, что он знает некоторый элемент из этого множества (или корректно применил функцию), не раскрывая этот элемент. Практика: эмитент предоставляет заранее дерево (или корень дерева), а пользователь использует SNARK, чтобы доказать знание пути к листу.

Например, в докладе разбирались два случая – **public list membership** и **private list membership**  . В первом случае проверяющий знает полный список (Merkle-дерево); доказывающий знает «секрет», хеш которого присутствует в дереве, и показывает доказательство пути к корню, не раскрывая сам путь целиком . Это удобно для анонимных голосований: верификатор видит полный список участников, а проголосовавший доказывает, что он из них. Примеры – проект Semaphore (анонимные группы) и смеситель Tornado Cash: пользователь доказывает, что он внес депозит, просто доказывая наличие его «секрета» в Merkle-каталоге, но не раскрывая, где именно .

Во втором случае (private list membership) проверяющий знает лишь корень дерева (доверяет его подписи), а само множество закрыто . Пользователь доказывает, что некоторый его секрет есть в этом (секретном) списке, снова с помощью ZKP. Такой подход назвали Verified Credentials: эмитент (например, банк) выдаёт «свидетельство» – корень подписанного Merkle-дерева, а пользователь доказывает свой атрибут (скажем, баланс) при помощи доказательства диапазона или других ZK-условий . При этом публичный блокчейн ничего не знает про список данных – видит только подписанный корень и короткое доказательство. Это позволяет, например, банковскому клиенту подтвердить свой доход или возраст без утечки личности, лишь агрегируя информацию на стороне эмитента.

**ZK-SNARK (расшифровка термина)**. Каждый компонент этой аббревиатуры означает важную характеристику:

- *Zero-Knowledge* – доказательство с нулевым разглашением: верификатор убедится, что утверждение верно (например, что доказывающий знает вход для функции, приводящий к данному выходу), но не узнает самого входа . Например, мы можем доказать, что число было возведено в миллионную степень и получился известный результат, не выдавая сам исходный множитель .
- *Succinct* – компактность: проверка такого доказательства происходит за время, существенно меньшее, чем само доказательство «в лоб» (вычисление функции). Доклад подчёркивает, что в идеале проверка ZK-пруфа занимает ничтожное время по сравнению с тяжёлой операцией, которую должен был совершить доказывающий . Это и делает возможным доверять супер-вычисления (например, громоздкие вычисления на суперкомпьютере) компактному электронному пруфу.
- *Non-Interactive* – неинтерактивность: в сетевом окружении (особенно в блокчейне) обмен сообщениями между доказывающим и проверяющим невозможен или нежелателен. Зато можно один раз сразу выдать полное доказательство (обычно с использованием «общей справочной строки» или метода Фиата–Шамира), которое проверяется без дополнительных запросов . Это свойство делает такие доказательства пригодными для включения в блокчейн-транзакцию одним полем.
- *Argument of Knowledge* – аргумент знания: это означает, что доказывающий должен эффективно знать некоторый секрет (значение), который порождает доказываемый вывод. Проще говоря, он не мог сгенерировать корректное доказательство, не зная нужных входных данных . Это даёт гарантию честности – «я не просто угадал правильный ответ, а действительно знаю решение».

Совокупность ZK-SNARKS обеспечивает мощную криптографию: можно, например, выполнять сложные вычисления и потом быстро убедить мир в корректности результата, при этом ничего не раскрывая о деталях. Доклад упоминает, что такие технологии ушли корнями в проверку вычислений на сверхкомпьютерах и сегодня активно применяются в блокчейнах (ZK-rollups, приватные вычисления, крипто-учётные записи и т.д.).

**Дерево Меркла**. Уже было сказано выше, что это структура для хранения множества данных (листов), где каждый непустой внутренний узел содержит хеш от конкатенации хешей своих детей. Таким образом корневой хеш – «Merkle root» – однозначно определяет все листья. Если нужно доказать, что элемент *A* входит в дерево, достаточно предоставить путь хешей от этого листа к корню  . Каждый хешовую операцию легко проверить: на каждом шаге вычисляем хеш текущей «цепочки» и сравниваем с родительским узлом. Если на выходе мы получаем корневой хеш, то доказательство верно. Это основной механизм, проверка которого очень эффективна.

Примеры применения: система BitTorrent строит Merkle-дерево от данных файла, чтобы сверять части при скачивании . В блокчейнах (например, Bitcoin) Merkle-деревья используются, чтобы узлы могли быстро удостовериться в включении транзакции в блок, не имея всех данных (достаточно доказательства из нескольких хешей). В целом, Merkle-дерево – это криптографический коммитмент к множеству (или к хранению данных), который позволяет быстро доказывать целостность и членство  .

**Verified Credentials на блокчейне.** Это более новая концепция из области децентрализованной идентификации и доверия. В отличие от централизованных сертификатов, версифицируемые креденшнлс (VC) позволяют любому эмитенту выдавать цифровые удостоверения (например, дипломы, права, справки) в стандарте W3C, которые можно проверять в любых системах, в том числе на блокчейне. Доклад иллюстрировал идею примером с банком: банк (issuer) готовит Merkle-дерево данных клиентов (балансов, кредитных лимитов и пр.) и подписывает корень. Пользователь (holder) хочет доказать, скажем, что его баланс больше 1000, без указания точной суммы. Он получает *свидетельство* – Merkle-доказательство своего листа и делает ZK-доказательство диапазона (range proof). В узле блокчейна (verifier) виден только публичный корень и короткий ZK-пруф. Если всё сходится, он доверяет, что клиент действительно имеет баланс в нужном диапазоне. Это даёт приватную верификацию атрибутов: сеть не знает конкретики, но знает, что атрибут прошёл проверку авторитетного эмитента . Аналогично, можно выдавать дипломы или сертификаты, привязанные к пользователям, и проверять их на блокчейне без раскрытия личности.

**Verkle-деревья и векторные коммитменты.** Это продвинутая тема из области хранения больших объёмов данных в блокчейне. Если обычное Merkle-дерево хранит хеши, то Verkle-дерево хранит **коммитменты к векторам** (обычно это полиномиальные коммитменты или KZG-коммитменты). Каждый узел Verkle-дерева «коммитит» сразу несколько подузлов. Главный плюс – доказательство членства элемента становится очень компактным, близким к константному размеру. Проще говоря, Merkle-пруф имеет сложность O(log N) (по уровню дерева), а Verkle может давать O(1) или O(log_k N) размер пруфа. В докладе подчёркнуто, что Ethereum уже переходит на такое хранение: чтобы, например, доказывать несколько состояний одной транзакции, было бы неэффективно дергать несколько Merkle-ключей. Вместо этого строят единый векторный коммитмент, и доказывают участие значений в нём.

По словам выступающего, Verkle-структуры используют ZK-коммитменты (например, KZG) «под капотом», которые делают векторные доказательства константного размера . Это значит: можно доказать, что элемент с индексом i равен определённому значению, используя пруф фиксированного объёма, даже если вектор огромный. Это «чудо» достигается за счёт того, что многовековый Merkle-пруф (из миллионов хешей) заменяется на крошечный ZK-пруф о полиноме. Это особенно важно для больших state-db: контракты в Ethereum, UTXO-базы биткоина и т.д. И действительно, Verkle (или k-ary Merkle) упоминаются как путь к тому, чтобы каждый узел хранил меньше, а валидаторы могли быстро проверять состояние сети.

**Сравнение характеристик подходов.** Обобщим отличия упомянутых схем:

- **Секреты и пороги.** Схемы типа Шамира и пороговых подписей не предполагают «скрытой» информации или анонимности – это скорее надёжное распределённое хранение. Они хорошо подходят там, где нужно, чтобы *несколько* узлов коллективно контролировали секрет: например, системы HSM или блокчейн-узлы, которые не могут единолично совершать действия. Квантовая устойчивость обеспечена, но сами схемы остаются чувствительны к количеству участников и сетевым сбоям.
- **Кольцевые подписи и анонимность.** Здесь наоборот ценится конфиденциальность отправителя. Это подход для «анонимных голосований» и «анонимных платежей». Минус – более сложный размер подписи (в традиционном плане длиннее обычной подписи) и ограничения на то, кто может быть в кольце. Поддерживают тот же уровень криптостойкости, но создают на первый взгляд «бо́льшие» подписи и требуют наличия публичного списка участников.
- **Агрегация подписей (BLS).** Суперэффективна для верификации множественных подписей: размер итоговой подписи мал и верификация лёгкая. Уязвимость – полагается на криптографию паринговых кривых, которая на сегодня устойчива, но может иметь свои опасения (хоть и сложнее, чем решать надрывные задачи). Важно, что BLS может быть объединена с пороговыми схемами (как увидели) и с кольцевыми (есть концепции кольцевых BLS).
- **Merkle vs Verkle.** Два подхода к доказательству членства. Merkle-пруф O(log N) по длине, доказательство – несколько десятков хешей. Очень надёжная и простая технология, но при больших деревьях и множественных верификациях может «тяжелеть». Verkle-пруф обещает O(1) размер (несколько полиномиальных точек), что выгодно, но в освоении ещё нова и требует доверия к ZK-коммитментам. Ethereum выбрал Verkle как путь вперед для state-tree.
- **ZK-SNARK и Set-membership.** Эти методы приносят приватность и компактность доказывания. Они дорогие в генерации и могут требовать трастовых установок (CRS), но дают возможность проверять вычисления или членство без раскрытия. Отличаются тем, что ZK-SNARK – это общий фреймворк с нулевым разглашением, пригодный для любых вычислений, а Set-membership / Verifiable Credentials – частные приложения (проверка данных из списка, диапазонные доказательства). Их характеристики: доказательство мало (обычно несколько сотен байт) и проверяется быстро , но генерация требует серьёзных вычислений и часто подготовки (например, долгий SNARK-препроцессинг).

## Выводы

Основная мысль – **криптография не стоит на месте**: появляются механизмы, расширяющие возможности безопасности и приватности.

Лично я отметил для себя несколько ключевых идей: 

1. Схемы разделения секрета теперь решают реальные задачи (это не только «проект студентов»). 
2. Пороговые и агрегированные подписи позволят в будущем ещё сильнее упростить консенсусные протоколы – представьте проверку одного короткого сигнатурного поля вместо десятков. И конечно, растущая популярность ZK-технологий (Set-membership, ZK-SNARK, Verkle) показывает, что приватность и экономия ресурсов – новые драйверы.

Я нахожу эти темы интересными но большинство идей требуют хороших математических знаний, которых у меня нет.
